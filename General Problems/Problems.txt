

472. Concatenated Words

class Solution {
public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        unordered_set<string> st(words.begin(), words.end());
        vector<string> ans;
        for(auto w : words){
            vector<bool> taken(w.size());
            if(rec(w, 0, taken, st)){
                ans.push_back(w);
            }
        }
        return ans;
    }
    bool rec(string &w, int sz, vector<bool>&taken, unordered_set<string>&st){
        if(sz == w.size()) return true;
        if(taken[sz]) return false;
        taken[sz] = true;
        for(int i = w.size()-(sz == 0 ? 1 : 0); i > sz; i--){
            if(st.count(w.substr(sz, i-sz)) && rec(w, i, taken, st)){
                return true;
            }
        }
        return false;
    }
};


352. Data Stream as Disjoint Intervals

class SummaryRanges {
public:
    map<int, int> m;
    SummaryRanges() {
        
    }
    
    void addNum(int val) {
        if(m.count(val)) return;
        m[val] = val;
        int mn = val, mx = val;
        if (m.count(val - 1)) mn = m[val-1];
        if (m.count(val + 1)) mx = m[val + 1];
        m[mn] = mx;
        m[mx] = mn;
    }
    
    vector<vector<int>> getIntervals() {
        vector<vector<int> > ans;
        auto it = m.begin();
        while(it != m.end()) {
            ans.push_back({it->first, it->second});
            it = m.upper_bound(it->second);
        }
        return ans;
    }
};

/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges* obj = new SummaryRanges();
 * obj->addNum(val);
 * vector<vector<int>> param_2 = obj->getIntervals();
 */


 460. LFU Cache

 class LFUCache {
public:
  int cap, id;
  unordered_map<int, tuple<int,int,int>> table;         
  set<tuple<int,int,int>>st;                            
  
  LFUCache(int capacity) {
    cap = capacity, id = 0;
  }
    
  int get(int key) {
    if(table.count(key)){
      auto [freq, old_id, val] = table[key];
      st.erase({freq, old_id, key});
      st.insert({++freq, ++id, key});
      table[key] = {freq, id, val};
      return val;
    }
    return -1;
  }
    
  void put(int key, int value) {
    if(cap == 0) return;
    if(table.count(key)){
      auto [freq, old_id, val] = table[key];
      st.erase({freq, old_id, key});
      st.insert({++freq, ++id, key});
      table[key] = {freq, id, value};
    }
    else {
      if(cap == table.size()){
        auto [freq, old_id, old_key] = *st.begin();
        st.erase(*st.begin());
        table.erase(old_key);
      }
      st.insert({1, ++id, key});
      table[key] = {1, id, value};
    }
  }
};

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache* obj = new LFUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */


1137. N-th Tribonacci Number

class Solution {
public:
    int tribonacci(int n) {
        int a = 0, b = 1, c = 1, d;
        if(n == 0)return a;
        if(n == 1)return b;
        if(n == 2)return c;
        for(int i = 3; i <= n; i++){
            d = a+b+c;
            a = b;
            b = c;
            c = d;
        }
        return d;
    }
};


1626. Best Team With No Conflicts

class Solution {
public:
    int bestTeamScore(vector<int>& scores, vector<int>& ages) {
        vector<pair<int, int>> vec;
        int n = scores.size();
        for(int i = 0; i < n; i++){
            vec.push_back({ages[i], scores[i]});
        }
        sort(vec.begin(), vec.end());
        vector<vector<int>> dp(n, vector<int>(n, -1));
        return rec(vec, dp, -1, 0);
    }
    int rec(vector<pair<int, int>>&vec, vector<vector<int>>&dp, int prev, int i){
        if(i >= vec.size()) return 0;
        if(dp[prev+1][i] != -1) return dp[prev+1][i];
        if(prev == -1 || vec[i].second >= vec[prev].second){
            return dp[prev+1][i] = max(rec(vec, dp, prev, i+1), vec[i].second+rec(vec, dp, i, i+1));
        }
        return dp[prev+1][i] = rec(vec, dp, prev, i+1);
    }
};

 
1071. Greatest Common Divisor of Strings

class Solution {
public:
    string gcdOfStrings(string str1, string str2) {
        return (str1+str2 == str2+str1) ? str1.substr(0, gcd(str1.size(), str2.size())) : "";
    }
};



953. Verifying an Alien Dictionary

class Solution {
public:
    bool isAlienSorted(vector<string>& words, string order) {
        unordered_map<char, int> mp;
        for(int i = 0; i < order.size(); i++) mp[order[i]] = i;
        for(int i = 0; i < words.size()-1; i++){
            for(int j = 0; j < words[i].size(); j++){
                if(j >= words[i+1].size()) return false;
                if(words[i][j] != words[i+1][j]){
                    if(mp[words[i][j]] > mp[words[i+1][j]]) return false;
                    else break;
                }
            }
        }
        return true;
    }
};


6. Zigzag Conversion

class Solution {
public:
    string convert(string s, int numrows) {
        if(numrows == 1) return s;
        string ans = "";
        int n = s.size(), sz = 2*(numrows-1);
        for(int i = 0; i < numrows; i++){
            int indx = i;
            while(indx < n){
                ans += s[indx];
                if(i != 0 && i != numrows-1){
                    int space = sz-2*i;
                    int sindx = indx+space;
                    if(sindx < n) ans += s[sindx];
                }
                indx += sz;
            }
        }
        return ans;
    }
};


567. Permutation in String

class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int n1 = s1.size(), n2 = s2.size();
        if(n1 > n2)return false;
        unordered_map<char, int> m1, m2;
        for(int i = 0; i < n1; i++){
            m1[s1[i]]++; m2[s2[i]]++;
        }    
        if(m1 == m2)return true;
        for(int i = n1; i < n2; i++){
            m2[s2[i]]++; m2[s2[i-n1]]--;
            if(m2[s2[i-n1]] == 0)m2.erase(s2[i-n1]);
            if(m1 == m2)return true;
        }
        return false;
    }
};


438. Find All Anagrams in a String

class Solution {
public:
    vector<int> findAnagrams(string s, string &p) {
        int m = s.size(), n = p.size();
        vector<int> ans;
        if(n > m)return ans;
        vector<int> vp(26, 0), vs(26, 0);
        for(int i = 0; i < n; i++)vp[p[i]-'a']++;
        for(int i = 0; i < n; i++)vs[s[i]-'a']++;
        if(vp == vs)ans.push_back(0);
        for(int i = 1; i < m-n+1; i++){
            vs[s[i+n-1]-'a']++; vs[s[i-1]-'a']--;
            if(vs == vp)ans.push_back(i);
        }
        return ans;
    }
};

1470. Shuffle the Array

class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        vector<int> ans(2*n);
        for(int i = 0, indx = 0; i < 2*n; i+=2, indx++){
            ans[i] = nums[indx], ans[i+1] = nums[n+indx];
        }
        return ans;
    }
};

904. Fruit Into Baskets

class Solution {
public:
    int totalFruit(vector<int>& s) {
        int n = s.size(), k = 2;
        if(n*k == 0)return 0;
        int l = 0, r = 0, ans = 1;
        map<int, int> mp;
        while(r < n){
            mp[s[r]] = r; r++;
            if(mp.size() == k+1){
                int l_indx = INT_MAX;
                for(pair<int, int> i : mp)l_indx = min(l_indx, i.second);
                mp.erase(s[l_indx]);
                l = l_indx+1;
            }
            ans = max(ans, r - l);
        }
        return ans;
    }
};



45. Jump Game II

class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size(), ans = 0, mx = 0, step = 0;
        for(int i = 0; i < n-1; i++){
            mx = max(mx, i+nums[i]);
            if(i == step)ans++, step = mx;
        }
        return ans;
    }
};


2306. Naming a Company

class Solution {
public:
    long long distinctNames(vector<string>& ideas) {
        unordered_set<string> us[26];
        for(auto& idea : ideas) us[idea[0]-'a'].insert(idea.substr(1));
        long long ans = 0;
        for(int i = 0; i < 25; i++){
            for(int j = i+1; j < 26; j++){
                int mutual = 0;
                for(auto &idea1 : us[i]){
                    if(us[j].count(idea1)){
                        mutual++;
                    }
                }
                ans += 2LL*(us[i].size()-mutual)*(us[j].size()-mutual);
            }
        }
        return ans;
    }
};



1162. As Far from Land as Possible

class Solution {
public:
    int maxDistance(vector<vector<int>>& grid) {
        vector<pair<int, int>> vec;
        int n = grid.size();
        bool zero = false;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j]) vec.push_back({i, j});
                else zero = true;
            }
        }
        if(vec.size() == 0 || !zero) return -1;
        int ans = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 0){
                    int tmp = INT_MAX;
                    for(auto k : vec){
                        int dist = abs(k.first - i) + abs(k.second-j);
                        tmp = min(tmp, dist);
                    }
                    ans = max(ans, tmp);
                }
            }
        }
        return ans;
    }
};


1129. Shortest Path with Alternating Colors

class Solution {
public:
    typedef pair<int, int> pr;
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        vector<vector<pr>> graph(n);
        for(auto r : redEdges) graph[r[0]].push_back({r[1], 0});
        for(auto b : blueEdges) graph[b[0]].push_back({b[1], 1});
        vector<vector<int>> vcost(n, vector<int>(2, -1));
        queue<pr> q;
        q.push({0, 0}); q.push({0, 1});
        vcost[0] = {0, 0};
        while(!q.empty()){
            auto [i, c1] = q.front(); q.pop();
            for(auto [j, c2] : graph[i]){
                if(vcost[j][c2] != -1 || c1 == c2)continue;
                vcost[j][c2] = 1 + vcost[i][c1];
                q.push({j, c2});
            }
        }
        vector<int> ans;
        for(auto& v : vcost){
            if(v[1] == -1 || (v[0] < v[1] && v[0] != -1)) v[1] = v[0];
            ans.push_back(v[1]);
        }
        return ans;
    }
};

2477. Minimum Fuel Cost to Report to the Capital

class Solution {
public:
    long long ans;
    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {
        int n = roads.size()+1;
        vector<vector<int>> graph(n);
        for(auto r : roads){
            graph[r[0]].push_back(r[1]);
            graph[r[1]].push_back(r[0]);
        }
        rec(graph, seats, 0, -1);
        return ans;
    }
    long long rec(vector<vector<int>> &graph, int &seats, int u, int parent){
        int curr = 1;
        for(auto v : graph[u]){
            if(v != parent){
                curr += rec(graph, seats, v, u);
            }
        }
        if(u != 0){
            ans += ceil((double)curr/seats);
        }
        return curr;
    }
    
};

1523. Count Odd Numbers in an Interval Range

class Solution {
public:
    int countOdds(int low, int high) {
        int ans = (high-low)/2;
        if((low&1) || (high&1)) ans++;
        return ans;
    }
};


67. Add Binary

class Solution {
public:
    string addBinary(string a, string b) {
        string res;
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0;
        while(i >= 0 || j >= 0){
            int sum = carry;
            if(i >= 0) sum += a[i--] - '0';
            if(j >= 0) sum += b[j--] - '0';
            carry = sum > 1 ? 1 : 0;
            res += to_string(sum % 2);
        }
        if(carry) res += to_string(carry);
        reverse(res.begin(), res.end());
        return res;
    }
};



989. Add to Array-Form of Integer

class Solution {
public:
    vector<int> addToArrayForm(vector<int>& num, int k) {
        int i = num.size()-1;
        int rem = 0;
        while(i >= 0 && k > 0){
            rem += (num[i]+k%10);
            if(rem < 10){
                num[i] = rem;
                rem = 0;
            } else{
                num[i] = rem%10;
                if(rem == 10) rem = 1;
                else rem /= 10;
            }
            k /= 10;
            i--;
        }
        while(i >= 0){
            rem += num[i];
            if(rem < 10){
                num[i] = rem;
                rem = 0;
                break;
            }else{
                num[i] = rem%10;
                rem /= 10;
            }
            k /= 10;
            i--;
        }
        while(k){
            rem += k%10;
            if(rem < 10){
                num.insert(num.begin(), rem%10);
                rem = 0;
            }else {
                num.insert(num.begin(), rem%10);
                if(rem == 10) rem = 1;
                else rem /= 10;
            }
            k /= 10;
        }
        if(rem)num.insert(num.begin(), rem);
        return num;
    }
};


104. Maximum Depth of Binary Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};

783. Minimum Distance Between BST Nodes

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int res = INT_MAX, pre = -1;
    int minDiffInBST(TreeNode* root) {
       if (root->left != NULL) minDiffInBST(root->left);
        if (pre >= 0) res = min(res, root->val - pre);
        pre = root->val;
        if (root->right != NULL) minDiffInBST(root->right);
        return res;
     }

};



226. Invert Binary Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root)return NULL;
        TreeNode *l = invertTree(root->left);
        TreeNode *r = invertTree(root->right);
        root->left = r;
        root->right = l;
        return root;
    }
};


103. Binary Tree Zigzag Level Order Traversal


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        if(!root)return ans;
        queue<TreeNode*> q;
        q.push(root);
        bool even = true;
        while(!q.empty()){
            vector<int> v;
            int n = q.size();
            for(int i = 0; i < n; i++){
                TreeNode *tmp = q.front(); q.pop();
                v.push_back(tmp->val);
                if(tmp->left)q.push(tmp->left);
                if(tmp->right)q.push(tmp->right);
            }
            if(!even)reverse(v.begin(), v.end());
            ans.push_back(v);
            even = !even;
        }
        return ans;
    }
};

35. Search Insert Position

class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int l = 0, r = n-1;
        while(l <= r){
            int mid = l + (r-l)/2;
            if(nums[mid] == target)return mid;
            else if(nums[mid] < target)l = mid+1;
            else r = mid-1;
        }
        return l;
    }
};





540. Single Element in a Sorted Array

class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int l = 0, r = nums.size()-2;
        while(l <= r){
            int mid = l + (r-l)/2;
            if(mid%2 == 0){
                if(nums[mid] != nums[mid+1]) r = mid-1;
                else l = mid+1;
            }else{
                if(nums[mid] == nums[mid+1]) r = mid-1;
                else l = mid+1;
            }
        }
        return nums[l];
    }
};


1011. Capacity To Ship Packages Within D Days

class Solution {
public:
    int shipWithinDays(vector<int>& weights, int days) {
        int r = accumulate(weights.begin(), weights.end(), 0);
        int l = max(r/days, *max_element(weights.begin(), weights.end()));
        while(l < r){
            int mid = l + (r-l)/2;
            if(possible(weights, days, mid)) r = mid;
            else l = mid+1;
        }
        return l;
    }
    bool possible(vector<int> weights, int days, int mid){
        int currsum = 0, ans = 1;
        for(auto w : weights){
            currsum += w;
            if(currsum > mid) ans++, currsum = w;
        }
        return ans <= days;
    }
};





502. IPO

class Solution {
public:
    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {
        int n = profits.size();
        vector<pair<int, int>> proj;
        for(int i = 0; i < n; i++) proj.emplace_back(capital[i], profits[i]);
        sort(proj.begin(), proj.end());
        priority_queue<int> pq;
        int ptr = 0;
        for(int i = 0; i < k; i++){
            while(ptr < n && proj[ptr].first <= w){
                pq.push(proj[ptr++].second);
            }
            if(pq.empty())break;
            w += pq.top(); pq.pop();
        }
        return w;
    }
};


1675. Minimize Deviation in Array

class Solution {
public:
    int minimumDeviation(vector<int>& nums) {
        priority_queue<int> pq; 
        int m = INT_MAX;
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2==0){
                pq.push(nums[i]);
                m = min(m,nums[i]);
            }
            else{
                pq.push(nums[i]*2);
                m = min(m,nums[i]*2);
            }
        }
        int ans = INT_MAX;
        while(!pq.empty()){
            int top = pq.top();
            pq.pop();
            ans = min(ans,top-m);
            if(top%2!=0){
                break;
            }
            m = min(m,top/2);
            pq.push(top/2);
        }
        return ans;
    }
};


121. Best Time to Buy and Sell Stock

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int ans = 0, mn = INT_MAX;
        for(int i = 0; i < n; i++){
            mn = min(mn, prices[i]);
            ans = max(ans, prices[i]-mn);
        }
        return ans;
    }
};



72. Edit Distance

class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1 = word1.size(), n2 = word2.size();
        int dp[n1+1][n2+1];
        for(int i = 0; i <= n1; i++){
            for(int j = 0; j <= n2; j++){
                if(i == 0)dp[i][j] = j;
                else if(j == 0)dp[i][j] = i;
                else if(word1[i-1] == word2[j-1])dp[i][j] = dp[i-1][j-1];
                else dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]));
            }
        }
        return dp[n1][n2];
    }
};



/*
// Definition for a QuadTree node.
class Node {
public:
    bool val;
    bool isLeaf;
    Node* topLeft;
    Node* topRight;
    Node* bottomLeft;
    Node* bottomRight;
    
    Node() {
        val = false;
        isLeaf = false;
        topLeft = NULL;
        topRight = NULL;
        bottomLeft = NULL;
        bottomRight = NULL;
    }
    
    Node(bool _val, bool _isLeaf) {
        val = _val;
        isLeaf = _isLeaf;
        topLeft = NULL;
        topRight = NULL;
        bottomLeft = NULL;
        bottomRight = NULL;
    }
    
    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {
        val = _val;
        isLeaf = _isLeaf;
        topLeft = _topLeft;
        topRight = _topRight;
        bottomLeft = _bottomLeft;
        bottomRight = _bottomRight;
    }
};
*/




427. Construct Quad Tree

class Solution {
public:
    Node* construct(vector<vector<int>>& grid) {
        int n = grid.size();
        return rec(grid, 0, n-1, 0, n-1);
    }
    Node* rec(vector<vector<int>>&grid, int l, int r, int t, int b){
        if(l == r || t == b) return new Node(grid[t][l], true);
        Node *root = new Node(1, false);
        root->topLeft = rec(grid, l, (r+l)/2, t, (b+t)/2);
        root->topRight = rec(grid, (r+l)/2+1, r, t, (b+t)/2);
        root->bottomLeft = rec(grid, l, (r+l)/2, (b+t)/2+1, b);
        root->bottomRight = rec(grid, (r+l)/2+1, r, (b+t)/2+1, b);
        if(root->topLeft->val == root->topRight->val && 
           root->topLeft->val == root->bottomLeft->val &&
           root->topLeft->val == root->bottomRight->val &&
           root->topLeft->isLeaf && root->topRight->isLeaf &&
           root->bottomLeft->isLeaf && root->bottomRight->isLeaf)
           {
            return new Node(root->topLeft->val, true);
        }
        return root;
    }
};




652. Find Duplicate Subtrees

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<string, vector<TreeNode*>> mp;
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        serialize(root);
        vector<TreeNode*> ans;
        for(auto i : mp){
            if(i.second.size() > 1)ans.push_back(i.second[0]);
        }
        return ans;
    }
    string serialize(TreeNode* root){
        if(!root) return "";
        string s = "("+serialize(root->left)+to_string(root->val)+serialize(root->right)+")";
        mp[s].push_back(root);
        return s;
    }
};




912. Sort an Array

class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> aux = nums;
        mergeSort(nums, aux, 0, n-1);
        return nums;
    }
    void mergeSort(vector<int> &nums, vector<int> &aux, int low, int high){
        if(low == high)return;
        int mid = low + (high-low)/2;
        mergeSort(nums, aux, low, mid);
        mergeSort(nums, aux, mid+1, high);
        merge(nums, aux, low, mid, high);
    }
    void merge(vector<int> &nums, vector<int> &aux, int low, int mid, int high){
        int k = low, i = low, j = mid+1;
        while(i <= mid && j <= high){
            if(nums[i] <= nums[j])aux[k++] = nums[i++];
            else aux[k++] = nums[j++];
        }
        while(i <= mid)aux[k++] = nums[i++];
        for(int i = low; i <= high; i++)nums[i] = aux[i];
    }
};




443. String Compression

class Solution {
public:
    int compress(vector<char>& chars) {
        int cnt = 0, n = chars.size(), i = 0;
        vector<char> v;
        while(i < n){
            int j = i+1, tmp = 1;
            char c = chars[i];
            while(j < n && chars[j] == c)j++, tmp++;
            if(tmp == 1)cnt++, i++, v.push_back(c);
            else if(tmp == 2)cnt+=2, i = j, v.push_back(c), v.push_back('2');
            else {
                v.push_back(c), cnt++;
                string s = to_string(tmp);
                for(auto ch : s){
                    v.push_back(ch), cnt++;
                }
                i = j;
            }
        }
        chars = v;
        return cnt;
    }
};




28. Find the Index of the First Occurrence in a String

class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.size(), m = needle.size();
        if(m == 0)return 0;
        if(n == 0)return -1;
        int i, j, p = 0, t = 0, h = 1, d = 256, q = 101;
        for(i = 0; i < m-1; i++) h = (h*d)%q;
        for(i = 0; i < m; i++){
            p = (d*p + needle[i]) % q;
            t = (d*t + haystack[i]) % q;
        }
        for(i = 0; i <= n-m; i++){
            if(p == t){
                for(j = 0; j < m; j++){
                    if(haystack[i+j] != needle[j]){
                        break;
                    }
                }
                if(j == m) return i;
            }
            if(i < n-m){
                t = (d*(t-haystack[i]*h) + haystack[i+m])%q;
                if(t < 0)t = (t+q);
            }
        }
        return -1;
    }
};


2444. Count Subarrays With Fixed Bounds

class Solution {
public:
    long long countSubarrays(vector<int>& nums, int minK, int maxK) {
        long long res = 0;
        bool minFound = false, maxFound = false;
        int start = 0, minStart = 0, maxStart = 0;
        for (int i = 0; i < nums.size(); i++) {
            int num = nums[i];
            if (num < minK || num > maxK) {
                minFound = false;
                maxFound = false;
                start = i+1;
            }
            if (num == minK) {
                minFound = true;
                minStart = i;
            }
            if (num == maxK) {
                maxFound = true;
                maxStart = i;
            }
            if (minFound && maxFound) {
                res += (min(minStart, maxStart) - start + 1);
            }
        }
        return res;
    }
};




1345. Jump Game IV

class Solution {
public:
    int minJumps(vector<int>& arr) {
        int n = arr.size();
        unordered_map<int, vector<int>> mp;
        for(int i = 0; i < n; i++) mp[arr[i]].push_back(i);
        vector<bool> vis(n); 
        queue<int> q;
        q.push(0), vis[0] = true;
        int cnt = 0;
        while(!q.empty()){
            for(int sz = q.size(); sz > 0; sz--){
                int i = q.front(); q.pop();
                if(i == n-1) return cnt;
                vector<int> &vec = mp[arr[i]];
                vec.push_back(i-1); vec.push_back(i+1);
                for(int j : vec){
                    if(j >= 0 && j < n && !vis[j]){
                        vis[j] = true;
                        q.push(j);
                    }
                }
                vec.clear();
            }
            cnt++;
        }
        return 0;
    }
};





1539. Kth Missing Positive Number


class Solution {
public:
    int findKthPositive(vector<int>& arr, int k) {
        int l = 0, r = arr.size()-1;
        while(l <= r){
            int mid = l + (r-l)/2;
            if(arr[mid]-mid-1 < k) l = mid+1;
            else r = mid-1;
        }
        return l+k;
    }
};



2187. Minimum Time to Complete Trips


class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        long long left = 0, right = totalTrips*(long long)time[0], ans = right;
        while(left < right){
            long long mid = (left+right)/2;
            long long count = 0;
            for(int i = 0; i < time.size(); ++i){
                count += mid/time[i]; 
            } 
            if(count >= totalTrips){
                ans = min(ans, mid); 
                right = mid;
            }else{
                left = mid+1;
            }
        }
        return ans;
    }
};





875. Koko Eating Bananas

class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int l= 1, r = *max_element(piles.begin(), piles.end());
        while(l < r){
            int mid = (l+r)/2;
            int hour = 0;
            for(int pile : piles) hour += ceil(pile/(double)mid);
            if(hour <= h) r = mid;
            else l = mid + 1;
        }
        return r;
    }
};





142. Linked List Cycle II

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode*> s;
        ListNode *tmp = head;
        while(tmp){
            if(s.find(tmp) != s.end())return tmp;
            s.insert(tmp);
            tmp = tmp->next;
        }
        return NULL;
    }
};




382. Linked List Random Node

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
  
    vector<int> vec;

    Solution(ListNode* head) {
        ListNode*tmp = head;
        while(tmp){
            vec.push_back(tmp->val);
            tmp = tmp->next;
        }
    }
    
    int getRandom() {
        int n = vec.size();
        return vec[rand()%n];
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(head);
 * int param_1 = obj->getRandom();
 */






109. Convert Sorted List to Binary Search Tree


 /**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        vector<int> vec;
        while(head){
            vec.push_back(head->val);
            head = head->next;
        }
        if(!vec.size()) return NULL;
        return rec(vec, 0, vec.size()-1);
    }
    TreeNode* rec(vector<int> vec, int l, int r){
        if(l > r) return NULL;
        int mid = (l+r)/2;
        TreeNode* root = new TreeNode(vec[mid]);
        root->left = rec(vec, l, mid-1);
        root->right = rec(vec, mid+1, r);
        return root;
    }
};




23. Merge k Sorted Lists

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode *ans = NULL, *tmp = NULL;
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int n = lists.size(), cnt = 0;
        while(cnt != n){
            ListNode *tmp = new ListNode(INT_MAX);
            for(int i = 0; i < n; i++){
                if(lists[i] == NULL)cnt++;
                else{
                    if(lists[i]->val < tmp->val)tmp = lists[i];
                }
            }
            if(cnt != n){
                cnt = 0;
                for(int i = 0; i < n; i++){
                    if(lists[i] != NULL && lists[i]->val == tmp->val){
                        lists[i] = lists[i]->next; cnt++;
                    }
                }
                while(cnt > 0)addNode(tmp->val), cnt--;
            }
        }
        return ans;
    }
    void addNode(int val){
        if(ans == NULL){
            ans = new ListNode(val);
            tmp = ans;
        }else{
            tmp -> next = new ListNode(val);
            tmp = tmp->next;
        }
    }
};





101. Symmetric Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root)return true;
        return rec(root->left, root->right);
    }
    bool rec(TreeNode *root1, TreeNode *root2){
        if(!root1 && !root2)return true;
        if(!root1 || !root2)return false;
        if(root1->val == root2->val) return rec(root1->left, root2->right) && rec(root1->right, root2->left);
        return false;
    }
};




129. Sum Root to Leaf Numbers


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    int sumNumbers(TreeNode* root) {
        rec(root, 0);
        return ans;
    }
    void rec(TreeNode* root, int curr){
        if(!root) return;
        curr = curr*10+root->val;
        if(!root->left && !root->right){
            ans += curr;
            return;
        };
        if(root->left) rec(root->left, curr);
        if(root->right) rec(root->right, curr);
    }
};






958. Check Completeness of a Binary Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        bool null = false;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            auto tmp = q.front(); q.pop();
            if(tmp == NULL) null = true;
            else{
                if(null) return false;
                q.push(tmp->left);
                q.push(tmp->right);
            }
        }
        return true;
    }
    int dfs(TreeNode* root){
        if(!root) return 0;
        return 1 + max(dfs(root->left), dfs(root->right));
    }
};







106. Construct Binary Tree from Inorder and Postorder Traversal


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorder, postorder;
    unordered_map<int, int> mp;
    int postIndx;
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        this->inorder = inorder, this->postorder = postorder;
        postIndx = postorder.size() - 1;
        int indx = 0;
        for(int val : inorder)mp[val] = indx++;
        return dfs(0, inorder.size()-1);
    }
    TreeNode* dfs(int inLeft, int inRght){
        if(inLeft > inRght)return NULL;
        int val = postorder[postIndx];
        TreeNode *root = new TreeNode(val);
        int indx = mp[val];
        postIndx--;
        root->right = dfs(indx+1, inRght);
        root->left = dfs(inLeft, indx-1);
        return root;
    }
};





208. Implement Trie (Prefix Tree)



class node{
    public:
    unordered_map<char, node*> mp;
    bool end = false;
};



class Trie {
public:
    
    node *root;
    node *curr;
    
    Trie() {
         root = new node;
    }
    
    void insert(string word) {
        curr = root;
        for(char c : word){
            if(!curr -> mp.count(c))curr -> mp[c] = new node;
            curr = curr-> mp[c];
        }
        curr -> end = true;
    }
    
    bool search(string word) {
        curr = root;
        for(char c : word){
            if(!curr-> mp.count(c))return false;
            curr = curr->mp[c];
        }
        return curr -> end;
    }
    
    bool startsWith(string prefix) {
        curr = root;
        for(char c : prefix){
            if(!curr-> mp.count(c))return false;
            curr = curr->mp[c];
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */




1472. Design Browser History


 class BrowserHistory {
public: 
    vector<string> vec;
    int indx;
    BrowserHistory(string homepage) {
        vec.push_back(homepage); 
        indx = 0;   
    }
    
    void visit(string url) {
        int n = vec.size()-1;
        while(n-- > indx){
            vec.pop_back();
        }
        indx++;
        vec.push_back(url);
    }
    
    string back(int steps) {
        indx -= steps;
        if(indx < 0) indx = 0;
        return vec[indx];
    }
    
    string forward(int steps) {
        indx += steps;
        if(indx >= vec.size()) indx = vec.size()-1;
        return vec[indx];
    }
};

/**
 * Your BrowserHistory object will be instantiated and called as such:
 * BrowserHistory* obj = new BrowserHistory(homepage);
 * obj->visit(url);
 * string param_2 = obj->back(steps);
 * string param_3 = obj->forward(steps);
 */




211. Design Add and Search Words Data Structure


 class TrieNode {
public:
    bool word;
    TrieNode* children[26];
    TrieNode() {
        word = false;
        memset(children, NULL, sizeof(children));
    }
};

class WordDictionary {
public:
    TrieNode* root = new TrieNode();
    WordDictionary() {
        
    }
    
    void addWord(string word) {
        TrieNode* node = root;
        for (char c : word) {
            if (!node -> children[c - 'a']) {
                node -> children[c - 'a'] = new TrieNode();
            }
            node = node -> children[c - 'a'];
        }
        node -> word = true;
    }
    
    bool search(string word) {
        return search(word.c_str(), root);
    }

    bool search(const char* word, TrieNode* node) {
        for (int i = 0; word[i] && node; i++) {
            if (word[i] != '.') {
                node = node -> children[word[i] - 'a'];
            } else {
                TrieNode* tmp = node;
                for (int j = 0; j < 26; j++) {
                    node = tmp -> children[j];
                    if (search(word + i + 1, node)) {
                        return true;
                    }
                }
            }
        }
        return node && node -> word;
    }
};




605. Can Place Flowers

class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int sz = flowerbed.size(), cnt = 0;
        for (int i = 0; i < sz; i++) {
            if ((i == 0 || flowerbed[i - 1] == 0) && flowerbed[i] == 0 && (i == sz - 1 || flowerbed[i + 1] == 0)) {
                flowerbed[i] = 1;
                cnt++;
            }
        }
        return cnt >= n;
    }
};










2348. Number of Zero-Filled Subarrays


class Solution {
public:
    long long zeroFilledSubarray(vector<int>& nums) {
        vector<int> zeroCnt;
        int n = nums.size(), cnt = 0;
        for(auto num : nums){
            if(num == 0)cnt++;
            else{
                if(cnt)zeroCnt.push_back(cnt);
                cnt = 0;
            }
        }
        if(cnt) zeroCnt.push_back(cnt);
        long long ans = 0;
        for(long long num : zeroCnt){
            ans += (num*(num+1)/2);
        }
        return ans;
    }
};



2492. Minimum Score of a Path Between Two Cities


class Solution {
public:
    int minScore(int n, vector<vector<int>>& roads) {
        vector<pair<int, int>> graph[n+1];
        for(auto r : roads){
           graph[r[0]].push_back({r[1], r[2]});
           graph[r[1]].push_back({r[0], r[2]});
        }
        int ans = INT_MAX;
        vector<int> vis(n+1, 0);
        queue<int> q; q.push(1);
        while(!q.empty()){
            int u = q.front(); q.pop();
            for(auto i : graph[u]){
                int v = i.first;
                int w = i.second;
                if(!vis[v]){
                    vis[v] = 1;
                    q.push(v);
                }
                ans = min(ans, w);
            }
        }
        return ans;
    }
};




1319. Number of Operations to Make Network Connected



class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& conn) {
        int cable = conn.size();
        if(cable < n-1)return -1;
        vector<int> graph[n];
        for(auto i : conn){
            graph[i[0]].push_back(i[1]);
            graph[i[1]].push_back(i[0]);
        }
        int ans = 0;
        vector<bool> vis(n, false);
        for(int i = 0; i < n; i++){
            if(!vis[i]){
                ans++;
                dfs(i, graph, vis);
            }
        }
        return ans-1;
    }
    
    void dfs(int u, vector<int> graph[], vector<bool> &vis){
        vis[u] = true;
        for(auto v : graph[u]){
            if(!vis[v])dfs(v, graph, vis);
        }
    }
};




1466. Reorder Routes to Make All Paths Lead to the City Zero


class Solution {
public:
    set<pair<int, int>> s;
    int ans = 0;

    int minReorder(int n, vector<vector<int>>& connections) {
        vector<int> graph[n];
        vector<bool> vis(n, false);
        for(auto i : connections){
            s.insert({i[0], i[1]});
            graph[i[0]].push_back(i[1]);
            graph[i[1]].push_back(i[0]);
        }
        dfs(graph, vis, 0, -1);
        return ans;
    }
    
    void dfs(vector<int> *graph, vector<bool> &vis, int src, int par){
        vis[src] = true;
        for(auto i : graph[src]){
            if(!vis[i]){
                if(s.find({src, i}) != s.end())ans++;
                dfs(graph, vis, i, src);
            }
        }
    }
};





2316. Count Unreachable Pairs of Nodes in an Undirected Graph


class Solution {
public:
    long long countPairs(int n, vector<vector<int>>& edges) {
        vector<vector<int>> graph(n);
        for(auto e : edges)graph[e[0]].push_back(e[1]), graph[e[1]].push_back(e[0]);
        vector<bool> vis(n, false);
        vector<int> vec;
        for(int i = 0; i < n; i++){
            if(!vis[i]){
                int cnt = 1;
                vis[i] = true;
                queue<int> q; q.push(i);
                while(!q.empty()){
                    int tmp = q.front(); q.pop();
                    for(int j : graph[tmp]){
                        if(!vis[j]){
                            vis[j] = true;
                            q.push(j);
                            cnt++;
                        }
                    }
                }
                vec.push_back(cnt);
            }
        }
        long long cntn = vec.size(), ans = 0, total = 0;
        for(int i = 0; i < cntn; i++){
            ans += 1LL*(vec[i]*(n-total-vec[i]));
            total += vec[i];
        } 
        return ans;
    }
};










2360. Longest Cycle in a Graph



class Solution {
    public int longestCycle(int[] edges) {
        int n = edges.length;
        int maxCycleLength = -1;
        boolean[] visited = new boolean[n];
        
        for(int i=0;i<n;i++){
            if(!visited[i]){
                Map<Integer, Integer> nodeToLevel = new HashMap<>();
                int cycleLength = bfs(i, edges, visited, nodeToLevel);
                maxCycleLength = Math.max(maxCycleLength, cycleLength);
            }
        }
        
        return maxCycleLength;
    }
    
    private int bfs(int node, int[] edges, boolean[] visited, Map<Integer, Integer> nodeToLevel){
        int level = 0;
        Queue<Integer> q = new LinkedList<>();
        q.add(node);
        visited[node] = true;
        int maxLevel = -1;
        
        while(!q.isEmpty()){
            int size = q.size();
            for(int i=0;i<size;i++){
                int parent = q.poll();
                nodeToLevel.put(parent, level);
                int child = edges[parent];
                if(child != -1){
                    if(!visited[child]){
                        q.add(child);
                        visited[child] = true;
                    }
                    else{
                        int preLevel = nodeToLevel.getOrDefault(child, -1);
                        if(preLevel != -1){
                            int diff = level-preLevel+1;
                            maxLevel = Math.max(maxLevel, diff);
                        }
                    }
                }
            }
            level++;
        }
        
        return maxLevel;
    }
}






64. Minimum Path Sum


class Solution {
public:
    int dp[205][205] = {};
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        return rec(grid, m-1, n-1);
    }
    int rec(vector<vector<int>> &grid, int m, int n){
        if(m < 0 || n < 0) return INT_MAX;
        if(m == 0 && n == 0) return grid[m][n];
        if(dp[m][n]) return dp[m][n];
        return dp[m][n] = grid[m][n] + min(rec(grid, m-1, n), rec(grid, m, n-1));
    }
};





983. Minimum Cost For Tickets

class Solution {
public:
    int dp[366];
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n = days.size();
        memset(dp, -1, sizeof dp);
        return rec(days, costs, 0, n);
    }
    int rec(vector<int> days, vector<int> costs, int i, int n){
        if(i >= n)return 0;
        if(dp[i] != -1)return dp[i];
        int a = costs[0] + rec(days, costs, i+1, n);
        int j;
        for(j = i; j < n && days[j] < days[i]+7; j++);
        int b = costs[1] + rec(days, costs, j, n);
        for(j = i; j < n && days[j] < days[i]+30; j++);
        int c = costs[2] + rec(days, costs, j, n);
        return dp[i] = min(a, min(b, c));
    }
};





1402. Reducing Dishes


class Solution {
public:
    int dp[505][505];
    int maxSatisfaction(vector<int>& satisfaction) {
        memset(dp, -1, sizeof dp);
        sort(satisfaction.begin(), satisfaction.end());
        return rec(satisfaction, 0, 1);
    }
    int rec(vector<int>&satisfaction, int indx, int time){
        if(indx == satisfaction.size()) return 0;
        if(dp[indx][time] != -1) return dp[indx][time];
        return dp[indx][time] = max(time*satisfaction[indx]+rec(satisfaction, indx+1, time+1), rec(satisfaction, indx+1, time));
    }
};




87. Scramble String


class Solution {
public:
    unordered_map<string, bool> dp;
    bool isScramble(string s1, string s2) {
        if(s1 == s2) return true;
        else if(s1.size() < 1) return false;
        int n = s1.size();
        string key = s1+"|"+s2;
        if(dp.count(key)) return dp[key];
        for(int i = 1; i < n; i++){
            //swapped
            if(isScramble(s1.substr(0, i), s2.substr(n-i, i)) && isScramble(s1.substr(i, n-i), s2.substr(0, n-i))) return dp[key] = true;
            //Not swapped
            if(isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i, n-i), s2.substr(i, n-i))) return dp[key] = true;
        }
        return dp[key] = false;
    }
};





1444. Number of Ways of Cutting a Pizza



#define ll long long

class Solution {
public:
    const int M = 1e9+7;
    int fun(vector<vector<int>> &vc , int ci , int cj ,  int cuts , vector<vector<vector<int>>> &dp){
        if(cuts==0){
            if(vc[ci][cj]>0) return 1;
            return 0;
        }
        if(dp[ci][cj][cuts] != -1) return dp[ci][cj][cuts];
        ll rows =0 , cols =0;
        for(int i = ci+1 ; i<vc.size()-1;i++){
            if(vc[i][cj]>=cuts && vc[ci][cj] - vc[i][cj]>0)
                rows = (rows + fun(vc,i,cj,cuts-1,dp))%M;
        }
        for(int j = cj+1 ; j<vc[0].size()-1;j++){
            if(vc[ci][j]>=cuts && vc[ci][cj] - vc[ci][j]>0)
                cols = (cols + fun(vc,ci,j,cuts-1,dp))%M;
        }
        return dp[ci][cj][cuts] = (rows + cols)%M;
    }

    int ways(vector<string>& pizza, int cuts) {
        int n = pizza.size();
        int m = pizza[0].size();
        vector<vector<vector<int>>> dp(n+1,vector<vector<int>> (m+1, vector<int>(cuts+1,-1)));
        vector<vector<int>> count_apple(n+1,vector<int> (m+1,0));
        for(int i = n-1; i>=0 ; i--){
            for(int j = m-1 ; j>=0 ; j--){
                count_apple[i][j] = count_apple[i+1][j] + count_apple[i][j+1] - count_apple[i+1][j+1] + int(pizza[i][j]=='A');
            }
        }
        ll ans = fun(count_apple,0,0,cuts-1,dp);
        return ans;
    }
};




704. Binary Search


class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int low = 0, high = n-1;
        while(low <= high){
            int mid = low + (high-low)/2;
            if(nums[mid] == target)return mid;
            else if(nums[mid] < target)low = mid+1;
            else if(nums[mid] > target)high = mid-1;
        }
        return -1;
    }
};





2300. Successful Pairs of Spells and Potions


class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {
        int m = potions.size();
        sort(potions.begin(), potions.end());
        int mx = potions[m-1];
        vector<int> ans;
        for(int spell : spells){
            long long div = ceil((1.0*success)/spell);
            if(div > mx){
                ans.push_back(0);
                continue;
            }
            auto indx = lower_bound(potions.begin(), potions.end(), div) - potions.begin();
            ans.push_back(m-indx);
        }
        return ans;
    }
};










881. Boats to Save People


class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        sort(people.begin(), people.end());
        int i = 0, j = people.size()-1, ans = 0;
        while(i <= j){
            ans++;
            if(people[i]+people[j] <= limit)i++;
            j--;
        }
        return ans;
    }
};






2405. Optimal Partition of String


class Solution {
public:
    int partitionString(string s) {
        int cnt = 1;
        unordered_set<char> us;
        for(auto ch : s){
            if(us.find(ch) != us.end()){
                cnt++;
                us.clear();
            }
            us.insert(ch);
        }
        return cnt;
    }
};






2439. Minimize Maximum of Array

class Solution {
public:
    int minimizeArrayValue(vector<int>& nums) {
        long long n = nums.size(), ans = 0, psum = 0;
        for(int i = 0; i < n; i++){
            psum += nums[i];
            ans = max(ans, (psum+i) / (i+1));
        }
        return ans;
    }
};




1254. Number of Closed Islands


class Solution {
public:
    int closedIsland(vector<vector<int>>& grid) {
        int c = 0;
        int n = grid.size();
        int m = grid[0].size();
        for(int i=0; i<n; i++)
            rec(grid,i,0), rec(grid,i,m-1);
        for(int j=0; j<m; j++)
            rec(grid,0,j), rec(grid,n-1,j);
        for(int i=0; i<n; i++)
            for(int j=0; j<m; j++)
                if(!grid[i][j])
                    rec(grid,i,j), c++;
        return c;
    }
    void rec(vector<vector<int>>& grid, int i, int j) {
        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]) return;
        grid[i][j] = 1;
        rec(grid,i-1,j);
        rec(grid,i,j-1);
        rec(grid,i+1,j);
        rec(grid,i,j+1);
    }
};







1020. Number of Enclaves



class Solution {
public:
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {-1, 1, 0, 0};

    int numEnclaves(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        if(m <= 2 || n <= 2) return 0;
        vector<vector<bool>> vis(m, vector<bool>(n));

        for(int i = 0; i < m; i++){
            if(grid[i][0] && !vis[i][0]) dfs(grid, vis, m, n, i, 0);
            if(grid[i][n-1] && !vis[i][n-1]) dfs(grid, vis, m, n, i, n-1);
        }
        for(int i = 0; i < n; i++){
            if(grid[0][i] && !vis[0][i]) dfs(grid, vis, m, n, 0, i);
            if(grid[m-1][i] && !vis[m-1][i]) dfs(grid, vis, m, n, m-1, i);
        }
        
        int cnt = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] && !vis[i][j])cnt++;
            }
        }
        return cnt;
    }

    void dfs(vector<vector<int>>&grid, vector<vector<bool>>&vis, int m, int n, int x, int y){
        if(x < 0 || x >= m || y < 0 || y >= n || !grid[x][y] || vis[x][y]) return;
        vis[x][y] = true;
        for(int i = 0; i < 4; i++){
            dfs(grid, vis, m, n, x+dx[i], y+dy[i]);
        }
        return;
    }
};







133. Clone Graph



/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> neighbors;
    Node() {
        val = 0;
        neighbors = vector<Node*>();
    }
    Node(int _val) {
        val = _val;
        neighbors = vector<Node*>();
    }
    Node(int _val, vector<Node*> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
};
*/

class Solution {
public:
    unordered_map<Node*, Node*> dp;
    Node* cloneGraph(Node* node) {
        if(!node)return node;
        if(dp.find(node) != dp.end())return dp[node];
        Node *ans = new Node(node->val);
        dp[node] = ans;
        for(Node *i : node->neighbors)ans->neighbors.push_back(cloneGraph(i));
        return ans;
    }
};







1857. Largest Color Value in a Directed Graph


class Solution {
public:
    int largestPathValue(string cs, vector<vector<int>>& edges) {
        int n = cs.size();
        vector<vector<int>> graph(n), cnt(n, vector<int>(26));
        vector<int> indeg(n);
        for (auto &e: edges) {
            graph[e[0]].push_back(e[1]);
            indeg[e[1]]++;
        }
        queue<int> q;
        for (int i = 0; i < n; ++i)if(indeg[i] == 0) q.push(i);
        int ans = 0, processed = 0;
        while (!q.empty()) {
            int sz = q.size();
            for(int i = 0; i < sz; i++){
                int u = q.front(); q.pop();
                processed++;
                ans = max(ans, ++cnt[u][cs[u]-'a']);
                for(auto v : graph[u]){
                    for(int k = 0; k < 26; k++) cnt[v][k] = max(cnt[v][k], cnt[u][k]);
                    if(--indeg[v] == 0) q.push(v);
                }
            }
        }
        return processed != n ? -1 : ans;
    }
};




20. Valid Parentheses


class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for(int i = 0; i < s.size(); i++){
            if(s[i] == '(' || s[i] == '{' || s[i] == '[')st.push(s[i]);
             else{
                if(!st.empty() && ((s[i]==')' && st.top()=='(') || 
                                   (s[i]==']' && st.top()=='[') || 
                                   (s[i]=='}' && st.top()=='{') ))st.pop();
                else return false; 
            }
        }
        if(st.empty())return true;
        return false;
    }
};     




2390. Removing Stars From a String

class Solution {
public:
    string removeStars(string s) {
        int n = s.size(), cnt = 0;
        string ans = "";
        for(int i = n-1; i >= 0; i--){
            if(s[i] == '*')cnt++;
            else{
                if(cnt > 0){
                    cnt--;
                    continue;
                }else{
                    ans += s[i];
                }
            }
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};








71. Simplify Path


class Solution {
public:
    string simplifyPath(string path) {
        stack<string> st;
        int n = path.size();
        string ans;
        for(int i = 0; i < n; i++){
            if(path[i] == '/') continue;
            string tmp;
            while(i < n && path[i] != '/'){
                tmp += path[i];
                i++;
            }
            if(tmp == ".") continue;
            else if(tmp == ".."){
                if(!st.empty()) st.pop();
            }else st.push(tmp);
        }
        while(!st.empty()){
            ans = "/" + st.top() + ans;
            st.pop();
        }
        if(ans.size() == 0) ans += "/";
        return ans;
    }
};




946. Validate Stack Sequences


class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        stack<int> s;
        int p_front = popped[0];
        int i = 0, j = 0, npush = pushed.size(), npop = popped.size();
        while(pushed[i] != p_front && i < npush)s.push(pushed[i]), i++;
        while(i < npush || j < npop){
            if(i < npush && j < npop && pushed[i] == popped[j]){
                i++, j++;
            }else if(!s.empty() && j < npop && s.top() == popped[j]){
                s.pop(); j++;
            }else if(i < npush){
                 s.push(pushed[i]); 
                 i++;
            }else return false;
        }
        return true;
    }
};









516. Longest Palindromic Subsequence



class Solution {
public:
    int dp[1005][1005];
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        return rec(s, 0, n-1);
    }
    int rec(string &s, int i, int n){
        if(i > n) return 0;
        if(i == n) return 1;
        if(dp[i][n]) return dp[i][n];
        if(s[i] == s[n]) return dp[i][n] = 2 + rec(s, i+1, n-1);
        return dp[i][n] = max(rec(s, i+1, n), rec(s, i, n-1));
    }
};






2218. Maximum Value of K Coins From Piles


class Solution {
public:
    int dp[1005][2005];
    int n;
    int maxValueOfCoins(vector<vector<int>>& piles, int k) {
        memset(dp, -1, sizeof dp);
        n = piles.size();
        return rec(piles, k, 0);
    }
    int rec(vector<vector<int>> &piles, int k, int i){          
        if(i == n || k == 0) return 0;
        if(dp[i][k] != -1) return dp[i][k];
        int ans = rec(piles, k, i+1), curr = 0;
        for(int j = 0; j < piles[i].size() && j < k; j++){
            curr += piles[i][j];
            ans = max(ans, curr+rec(piles, k-j-1, i+1));
        }
        return dp[i][k] = ans;
    }
};







1639. Number of Ways to Form a Target String Given a Dictionary



class Solution {
public:
    typedef long long ll;
    int mod = 1e9+7;
    vector<vector<int>> v;
    int dp[1001][1001];
    int numWays(vector<string>& words, string target) {
        memset(dp, -1, sizeof(dp));
        int n = words[0].size();
        v.resize(n, vector<int>(26, 0));
        for(auto w : words){
            for(int i = 0; i < n; i++) v[i][w[i] - 'a']++;
        }
        return rec(0, 0, target);
    }
    ll rec(int i, int k, string &target){
        if(i >= target.size()) return 1;
        if(k >= v.size()) return 0;
        if(dp[i][k] != -1) return dp[i][k];
        int res = (v[k][target[i] - 'a'] * rec(i+1, k+1, target)) % mod;
        return dp[i][k] = res = (res+rec(i, k+1, target))%mod;
    }
};









1431. Kids With the Greatest Number of Candies


class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {
        int mx = 0;
        for(auto candy : candies) mx = max(mx, candy);
        vector<bool> ans;
        for(auto candy : candies) {
            if(candy+extraCandies >= mx) ans.push_back(true);
            else ans.push_back(false);
        }
        return ans;
    }
};







1768. Merge Strings Alternately



class Solution {
public:
    string mergeAlternately(string word1, string word2) {
        int n1 = word1.size(), n2 = word2.size();
        string ans = "";
        int n = min(n1, n2);
        for(int i = 0; i < n; i++){
            ans += word1[i];
            ans += word2[i];
        }
        if(n == n1)ans += word2.substr(n);
        if(n == n2)ans += word1.substr(n);
        return ans;
    }
};








1372. Longest ZigZag Path in a Binary Tree



/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxStep = 0;
    int longestZigZag(TreeNode* root) {
        dfs(root, true, 0);
        dfs(root, false, 0);
        return maxStep;
    }
    void dfs(TreeNode* root, bool isLeft, int step) {
        if (!root) return;
        maxStep = max(maxStep, step); 
        if (isLeft) {
            dfs(root->left, false, step + 1); 
            dfs(root->right, true, 1); 
        } else {
            dfs(root->right, true, step + 1); 
            dfs(root->left, false, 1); 
        }
    }
};











662. Maximum Width of Binary Tree


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        if(!root) return 0;
        queue<pair<TreeNode*, long>> q;
        q.push({root, 1});
        int ans = 0, first, last, diff;
        while(!q.empty()){
            int n = q.size(); 
            for(int i = 0; i < n; i++){
                auto [tmp, indx] = q.front(); q.pop();
                if(i == 0){
                    first = indx, diff = indx-1;
                }
                if(i == n-1) last = indx;
                indx -= diff;
                if(tmp->left)q.push({tmp->left, 2*indx-1});
                if(tmp->right)q.push({tmp->right, 2*indx});
            }
            ans = max(ans, last-first+1);
        }
        return ans;
    }
};








879. Profitable Schemes


class Solution {
public:
    int mod = 1e9+7;
    int dp[101][101][101];
    int profitableSchemes(int n, int mp, vector<int>& group, vector<int>& profit) {
        memset(dp, -1, sizeof dp);
        return rec(0, n, mp, group, profit);
    }
    int rec(int i, int n, int mp, vector<int> &group, vector<int>& profit){
        if(n < 0) return 0;
        if(i == group.size()){
            if(mp == 0) return 1;
            return 0;
        }
        if(dp[i][n][mp] != -1) return dp[i][n][mp];
        return dp[i][n][mp] = (rec(i+1, n, mp, group, profit) + rec(i+1, n-group[i], max(0, mp-profit[i]), group, profit)) % mod;
    }
};